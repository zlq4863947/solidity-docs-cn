###############################
智能合约简介
###############################

.. _simple-smart-contract:

***********************
一个简单的智能合约
***********************

让我们从一个基本示例开始，该示例设置变量的值并公开
供其他合约访问。 如果你不明白也没关系
现在一切都好，我们稍后会详细介绍。

存储示例存储示例
===============

.. code-block:: solidity

    // SPDX-License-Identifier: GPL-3.0
    pragma solidity >=0.4.16 <0.9.0;

    contract SimpleStorage {
        uint storedData;

        function set(uint x) public {
            storedData = x;
        }

        function get() public view returns (uint) {
            return storedData;
        }
    }

第一行告诉您源代码的许可授权为GPL3.0。机器可读的许可证说明符很重要，
应默认设置在发布的源代码中。

下一行指定源代码是为
Solidity >= 0.4.16 版，且 < 0.9.0 版。
这是为了确保合约无法使用新的（破坏性的）编译器版本进行编译，因为它的行为可能会有所不同。
:ref:`Pragmas<pragma>` 为告知编译器如何处理源代码（例如 `pragma once <https://zh.wikipedia.org/wiki/Pragma_once>`_ ）。

Solidity 合约的意义是一组代码（它的 *方法* ）和
驻留在以太坊区块链的特定地址的数据（它的 *状态* ）。 ``uint storedData;`` 行，声明了一个名为 ``storedData`` 的状态变量，它的类型为 ``uint`` （256 位无符号整数）。您可以将其视为数据库中的一个位置(数据字段)，您可以通过调用管理数据库的代码进行查询和修改。在这个例子中，合约定义了
可用于修改的方法 ``set`` 和 ``get`` 以检索变量的值。

要访问当前合约的成员（例如状态变量），通常不需要添加 ``this.`` 前缀，
您只需通过其名称直接访问它。与其他一些语言不同，省略它不仅仅是风格问题，
它导致以完全不同的方式访问成员，稍后会详细介绍。

除了（由于以太坊构建的基础构架）允许 ``任何人`` 存储 ``世界上任何人`` 都可以访问的单个数字外，该合约并没有做太多事情，而没有（可行的）方法来阻止您发布该数字。 ``任何人`` 都可以使用不同的值再次调用 ``set`` 并覆盖您的数字，但该数字仍存储在区块链的历史记录中。稍后，您将看到如何设置访问限制，以便只有您可以更改这个数字。

.. 警告::

    使用 Unicode 文本时要小心，因为外观相似（甚至相同）的字符，可能具有不同的字符编码，因此被编码为不同的字节数组。

.. 注解::
    所有标识符（合约名称、方法名称和变量名称）都只能使用ASCII 字符集。 可以将 UTF-8 编码的数据存储在字符串变量中。

.. index:: ! subcurrency

货币合约示例
===================

以下合约实现了最简单的加密货币。该合约只允许其创建者创建新的代币（不同的发行方案也是可能的）。
任何人都可以相互发送代币，而无需使用用户名和密码进行注册，您只需要一个以太坊密钥对。

.. code-block:: solidity

    // SPDX-License-Identifier: GPL-3.0
    pragma solidity ^0.8.4;

    contract Coin {
        // 关键字“public”使变量可以让其他合约访问
        address public minter;
        mapping (address => uint) public balances;

        // 事件可以允许客户端对您声明的特定合约事件做出反应
        event Sent(address from, address to, uint amount);

        // 构造方法的代码仅在创建合约时运行
        constructor() {
            minter = msg.sender;
        }

        // 将一定数量的新创建的代币发送到一个地址
        // 只能由合约创建者调用
        function mint(address receiver, uint amount) public {
            require(msg.sender == minter);
            balances[receiver] += amount;
        }

        // 错误允许您提供有关操作失败原因的信息。它们返回给方法的调用者。
        error InsufficientBalance(uint requested, uint available);

        // 从调用者账户向一个地址发送一定数量的现有代币
        function send(address receiver, uint amount) public {
            if (amount > balances[msg.sender])
                revert InsufficientBalance({
                    requested: amount,
                    available: balances[msg.sender]
                });

            balances[msg.sender] -= amount;
            balances[receiver] += amount;
            emit Sent(msg.sender, receiver, amount);
        }
    }

这个合约引入了一些新的概念，让我们一一介绍。

``address public minter;`` 行，声明了一个 :ref:`address<address>` 类型的状态变量。

``address`` 类型是一个 160 位的值，不允许任何算术运算。
它适用于存储合约地址，或属于 :ref:`外部用户<accounts>` 的密钥对公共部分的哈希值。

关键字 ``public`` 自动生成一个方法，允许您从合约外部访问状态的当前值。如果没有这个关键字，其他合约就无法访问该变量。
编译器生成的方法代码等价于如下（请暂时忽略 ``external`` 和 ``view`` ）：

.. code-block:: solidity

    function minter() external view returns (address) { return minter; }

你可以自己添加一个类似上面的方法，但是你会有一个同名的方法和状态变量。
您不需要这样做，编译器会帮您实现它。

.. index:: mapping

下一行，``mapping (address => uint) public balances;`` 也是创建一个公共状态变量，但它是一种更复杂的数据类型。
:ref:`mapping <mapping-types>` 类型将地址映射为 :ref:`无符号整数 <integers>`。

映射可以看作是 `哈希表 <https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8>`_，
它们被虚拟初始化，使得每个 ``可能的键`` 从一开始就存在，并映射到一个字节表示 ``全为零的值`` 。 但是，这种类比并不太恰当，因为它既不能获得映射的` `所有键`` 的列表，也不能获得 ``所有值`` 的列表。因此，应记录您添加到映射中的内容，或在不需要的上下文中使用它。 或者更好的是，保留一个列表，或者使用更合适的数据类型。

在映射的情况下，由 ``public`` 关键字创建的 :ref:`getter function<getter-functions>` 更为复杂。 它看起来像如下所示：

.. code-block:: solidity

    function balances(address _account) external view returns (uint) {
        return balances[_account];
    }

您可以使用该方法查询单个账户的余额。

.. index:: event

``event Sent(address from, address to, uint amount);`` 行，声明了一个 :ref:`"事件" <events>`，它在方法 ``send`` 的最后一行发出。 以太坊客户端（例如 Web 应用程序）可以
无需花费太多成本即可侦听区块链上发出的这些事件。一旦发出，侦听器就会收到参数 ``from``、 ``to`` 和 ``amount``，这使得跟踪交易成为可能。

要侦听此事件，您可以使用以下 JavaScript 代码，它使用 `web3.js <https://github.com/ethereum/web3.js/>`_ 来创建 ``Coin`` 合约对象，并且用户界面都会调用自动生成的 ``balances`` 上面的方法::

    Coin.Sent().watch({}, '', function(error, result) {
        if (!error) {
            console.log("Coin transfer: " + result.args.amount +
                " coins were sent from " + result.args.from +
                " to " + result.args.to + ".");
            console.log("Balances now:\n" +
                "Sender: " + Coin.balances.call(result.args.from) +
                "Receiver: " + Coin.balances.call(result.args.to));
        }
    })

.. index:: coin

:ref:`constructor<constructor>` 是一个特殊的方法，在合约创建期间执行，之后无法调用。在这种情况下，它会永久存储合约创建者的地址。 ``msg`` 变量（与 ``tx`` 和 ``block`` 一起）是一个特殊的 :ref:`全局变量 <special-variables-functions>`，它包含允许访问区块链的属性。 ``msg.sender`` 始终是当前（外部）方法调用的来源地址。此方法构建合约以及用户和合约可以调用的方法 ``mint`` 和 ``send`` 。

``mint`` 方法将一定数量的新创建的代币发送到另一个地址。 :ref:`require <assert-and-require>` 方法调用定义了如果不满足则还原所有更改的条件。 在这个例子中，``require(msg.sender == minter);`` 确保只有合约的创建者才能调用 ``mint``。 一般来说，创建者可以铸造任意数量的代币，但在某些时候，这会导致一种称为 ``溢出`` 的现象。请注意，由于默认的 :ref:`校验算法 <unchecked>`，如果表达式 ``balances[receiver] += amount;`` 溢出，即任意精度算术中的 ``balances[receiver] + amount`` > ``uint`` ( ``2**256 - 1``) 的最大值时，交易将回滚。 对于 ``send`` 方法中的语句 ``balances[receiver] += amount;`` 也将中断不被执行。

:ref:`Errors <errors>` 允许您向调用者提供有关条件或操作失败原因的更多信息。Errors与 :ref:`revert语句 <revert-statement>` 一起使用。 revert 语句无条件地中止和恢复 ``require`` 方法的所有更改，但它还允许您提供错误的名称和将提供给调用者（最终提供给前端应用程序）的附加数据 或区块链浏览器），以便可以更轻松地调试或应对故障。

任何人（已经拥有其中一些代币的人）都可以使用 ``send`` 方法将代币发送给其他任何人。如果发送方没有足够的代币可以发送，则 ``if`` 条件为真，则 ``revert`` 将导致操作失败，同时使用 ``InsufficientBalance`` 将错误发送给调用方，提供错误详细信息。

.. 注解::
    如果您使用此合约将代币发送到某个地址，则在区块链浏览器上查看该地址时将看不到任何内容，因为您发送代币的记录和更改的余额仅存储在该特定合约的数据中。通过使用事件，您可以创建一个 ``区块链浏览器`` 来追您的新币的交易和余额，而且您需要检查代币合约地址而不是代币所有者的地址。

.. _blockchain-basics:

*****************
区块链基础
*****************

区块链作为一个概念对于程序员来说并不难理解。原因是大多数的复杂概念（挖矿、`哈希 <https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A2%BC%E9%9B%9C%E6%B9%8A%E5%87%BD%E6%95%B8>`_、`椭圆曲线加密 <https://zh.wikipedia.org/wiki/%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%AF%86%E7%A0%81%E5%AD%A6>`_、`点对点网络 <https://zh.wikipedia.org/wiki/%E5%B0%8D%E7%AD%89%E7%B6%B2%E8%B7%AF>`_ 等）只是为了给平台提供一套特定的功能和承诺。您只需接受这些既有特性，而不必担心底层技术 —— 换句话说，您是否需要了解Amazon的AWS的内部如何工作才能使用它？

.. index:: transaction

事务
============

区块链是一个全世界共享的交易数据库。
这意味着每个人都可以通过加入网络来读取数据库中的数据。
如果您想更改数据库中的某些内容，您需要创建一个被其他所有人所接受的 ``事务``。
事务一词意味着您所进行的更改（假设您要同时更改两个值）要么根本没有完成，要么完全更改。此外，当您的事务被应用到数据库时，没有其他事务可以改变它。

例如，假设有一个表格，其中列出了所有电子货币账户的余额。如果请求从一个帐户转移到另一个帐户，则数据库的事务特性确保如果从一个帐户中减去该金额，则始终将其添加到另一个帐户中。如果由于某种原因无法将金额添加到目标帐户，则源帐户也不会被修改。

此外，交易始终由发送者（创建者）进行加密签名。
这使得保护对数据库特定修改的访问变得简单。在电子货币的例子中，简单的检查确保只有持有账户密钥的人才能从中转账。

.. index:: ! block

区块
======

要克服的一个主要障碍是所谓的 ``双花攻击`` （比特币术语）： 如果网络中存在两个都想清空帐户的交易，会发生什么？
只有一个交易是有效的，通常是 ``第一个`` 被接受的交易。
问题在于 ``第一个`` 在点对点网络中并不是一个客观的术语。

对此的抽象答案您不必关心。将为您选择一个全世界接受的交易顺序，以解决冲突。交易将被捆绑到所谓的 ``区块`` 中，然后它们将在所有参与的节点之间执行和分发。
当两笔交易相互冲突，最后成为第二笔的交易将被拒绝，不会成为区块的一部分。

这些区块在时间上形成线性序列，这就是 ``区块链`` 一词的来源。区块以相当规律的时间间隔添加到链中 —— 对于以太坊来说，这大约是每 17 秒一次。

作为 ``订单选择机制`` （亦被称为 ``挖矿`` ）的一部分，可能会不时回滚区块，但仅在链的 ``尖端`` 发生。在特定区块的顶部添加的区块越多，该块回滚的可能性越小。因此，您的交易虽可能会被还原甚至从区块链中删除，但随着您等待的时间越长，它就越不可能发生。

.. 注解::
    交易并不保证包含在下一个区块或任何特定的未来区块中，
    因为这不取决于交易的提交者，而是取决于矿工来确定交易包含在哪个区块中。

    如果您想安排合约的未来调用，您可以使用 `以太坊闹钟 <https://www.ethereum-alarm-clock.com/>`_ 或类似的 预言机服务。

.. _the-ethereum-virtual-machine:

.. index:: !evm, ! ethereum virtual machine

****************************
以太坊虚拟机
****************************

概述
========

以太坊虚拟机（EVM） 是以太坊智能合约的运行时环境。它不仅被沙盒化，而且实际上是完全隔离的，这意味着在 EVM 中运行的代码无法访问网络、文件系统或其他进程。
甚至智能合约之间的访问也很有限。

.. index:: ! account, address, storage, balance

.. _accounts:

账户
========

以太坊中有两种账户共享相同的地址空间： **外部账户** 由公钥私钥对（即人类）控制和 **合约账户** 由存储在一起的代码控制。

外部账户的地址是由公钥决定的，而合约的地址是在合约创建时决定的（它是由创建者地址和从该地址发送的交易数量得出的，即所谓的 ``nonce``）。

无论帐户是否存储代码，EVM 对这两种类型都一视同仁。

每个帐户都有一个持久的键值存储，其中 key 和 value 的长度都是256位，称为 **存储**。

此外，每个账户都有一个以太币的 **余额** （单位为 **Wei** ，**1 ether** = **10**18 wei** ），可以通过发送包含以太币的交易来修改。

.. index:: ! transaction

交易
============

交易是从一个账户发送到另一个账户的消息（可能相同或为空，见下文）。
它可以包含二进制数据（称为 **payload** ）和以太币。

如果目标帐户包含代码，则执行该代码并将有效 **payload** 作为输入数据提供。

如果目标账户没有设置（交易没有接收方或者接收方设置为 ``null`` ），则交易将创建一个 **新合约** 。
如前所述，该合约的地址不是零地址，而是从发送者及其发送的交易数量（ **nonce** ）派生的地址。此类合约创建交易的有效 **payload** 被视为 EVM 字节码并执行。本次执行的输出数据作为合约代码永久保存。
这意味着为了创建合约，您不会发送合约的实际代码，而是在执行时返回该代码的实际代码。

.. 注解::
  在创建合约过程中，其代码仍然是空的。
  因此，在构造函数完成执行之前，您不应回调正在构造的合约。

.. index:: ! gas, ! gas price

Gas
===

在创建时，每笔交易都会被收取一定数量的 **gas**，其目的是限制执行交易所需的工作量并同时为这次执行支付费用。在 EVM 执行交易的同时，gas 根据特定规则逐渐耗尽。

**gas价格** 是交易创建者设定的值，他必须从发送账户预先支付 ``gas_price * gas``。
如果执行后还剩下一些gas，则以同样的方式返还给创建者。

一旦gas耗尽（即它会是负数），就会触发一个out-of-gas异常，这将回滚当前调用帧中的状态所做的所有修改。

.. index:: ! storage, ! memory, ! stack

存储、内存和堆栈
=============================

以太坊虚拟机具有三个可以存储数据的区域——存储、内存和堆栈，这将在以下段落中进行解释。

每个账户都有一个叫做 **storage（存储）** 的数据区，它在函数调用和交易之间是持久的。
存储是一个持久的键值存储，其中 key 和 value 的长度都是256位。
不可能从合约中枚举存储，读取成本相对较高，初始化和修改存储的成本更高。由于此成本，您应该将持久存储中存储的内容最小化为合约需要运行的内容。
在合约之外的存储数据，如派生计算、缓存和聚合。
合约不能读取或写入除自身之外的任何存储。

第二个数据区称为 **内存**，其中一个合约为每个消息调用获取一个被清除的实例。内存是线性的，可以按字节级别寻址，但读取的宽度限制为 256 位，而写入的宽度可以为 8 位或 256 位。当访问（读取或写入）以前未触及的内存字（即字内的任何偏移量）时，内存会扩展一个字（256 位）。 在扩建时，必须支付gas费用。内存越大，成本越高（按二次方扩展）。

EVM 不是寄存器机而是堆栈机，因此所有计算都在称为 **堆栈** 的数据区域上执行。 它的最大大小为 1024 个元素，包含 256 位的字。 通过以下方式访问堆栈仅限于顶端：
可以将最上面的 16 个元素之一复制到堆栈的顶部，或者将最上面的元素与其下方的 16 个元素之一交换。
所有其他操作从堆栈中取出最顶部的两个（或一个或多个，取决于操作）元素并将结果压入堆栈。
当然，可以将堆栈元素移动到存储或内存中，以便更深入地访问堆栈，但 **不能在不首先移除堆栈顶部元素** 的情况下访问堆栈中更深处的任意元素。

.. index:: ! instruction

指令集
===============

EVM 的指令集保持尽量少，以避免可能导致共识问题的不正确或不一致的实现。
所有指令可以对基本数据类型、256 位字或内存片（或其他字节数组）进行操作。
存在通常的算术、位、逻辑和比较操作。
条件跳转和无条件跳转都是可能的。此外，合约可以访问当前块的相关属性，例如其编号和时间戳。

有关完整列表，请参阅 :ref:`操作码列表 <opcodes>` 作为内联汇编文档的一部分。

.. index:: ! message call, function;call

消息调用
=============

合约可以通过消息调用的方式调用其他合约或向非合约账户发送 以太币。消息调用类似于事务，因为它们具有源、目标、payload、以太、gas和返回数据。
事实上，每个事务都包含一个顶级消息调用，而后者又可以创建更多的消息调用。

合约可以决定应该通过内部消息调用发送多少剩余的 **gas** 以及它想要保留多少。
如果在内部调用（或任何其他异常）中发生了气体耗尽异常，这将通过放入堆栈的错误值来表示。
在这种情况下，只有与调用一起发送的气体才会被用完。
在 Solidity 中，在这种情况下，调用合约默认会导致手动异常，因此异常会“冒泡”调用堆栈。

如前所述，被调用的合约（可以与调用者相同）将收到一个新清除的内存实例，并可以访问调用有效负载 d—— 它将在一个名为 **calldata** 的单独区域中提供。
执行完成后，它可以返回数据，这些数据将存储在调用者预先分配的调用者内存中的某个位置。
所有这些调用都是完全同步的。

调用被**限制**到 1024 的深度，这意味着对于更复杂的操作，应该首选循环而不是递归调用。此外，消息调用中只能转发63/64th的gas，这导致实际中的深度限制略低于1000。

.. index:: delegatecall, callcode, library

委托调用/代码调用和库
=====================================

存在一个名为 **委托调用（delegatecall）** 的消息调用的特殊变体，它和一般的消息调用的区别在于，目标地址的代码将在发起调用的合约的上下文中执行。
与消息调用相同 ``msg.sender`` 和 ``msg.value`` 的值都不会被改变。

这意味着合约可以在运行时从不同地址动态加载代码。存储、当前地址和余额仍然是指调用合约，只是代码取自被调用地址。

这使得在 Solidity 中实现 **库** 功能成为可能：
可应用于合约存储的可重用库代码，例如：用来实现复杂的数据结构。

.. index:: log

日志
====

可以将数据存储在特殊索引的数据结构中，该结构一直映射到区块级别。
Solidity 使用这个称为 **日志** 的功能来实现 :ref:`事件 <events>`。
合约创建后无法访问日志数据，但可以从区块链外部高效访问它们。
由于日志数据的某些部分存储在 `bloom 过滤器 <https://zh.wikipedia.org/wiki/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8>`_ 中，因此可以以有效且加密安全的方式搜索这些数据，所以对于那些没有下载整个区块链网络节点的人（所谓的“轻客户端”）仍然可以找到这些日志。

.. index:: contract creation

创建
======

合约甚至可以使用特殊的操作码创建其他合约（即它们不像交易那样简单地调用零地址）。
这些 **创建调用** 和普通消息调用之间的唯一区别是执行有效载荷数据并将结果存储为代码，调用者/创建者在堆栈上接收新合约的地址。

.. index:: selfdestruct, self-destruct, deactivate

停用和自毁
============================

从区块链中删除代码的唯一方法是该地址的合约执行 ``自毁`` 操作时。存储在该地址的剩余 Ether 被发送到指定的目标，然后存储和代码从状态中删除。理论上删除合约听起来是个好主意，但它有潜在的危险，如果有人将以太币发送到删除的合约中，以太币就永远丢失了。

.. 警告::
    即使合约被 ``自毁`` 删除，它仍然是区块链历史的一部分，并且可以被大多数以太坊节点保留。
    所以使用 ``自毁`` 和从硬盘上删除数据是不一样的。

.. 注解::
    即使合约的代码不包含对 ``自毁`` 的调用，
    它仍然可以使用 ``自毁`` 或 ``代码调用`` 来执行该操作。

如果你想停用你的合约，你应该通过改变内部状态来 **禁用** 合约。以使得合约无法使用，并原路退回以太币。
